<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scala on kobtea.net</title>
    <link>http://kobtea.net/tags/scala/</link>
    <description>Recent content in Scala on kobtea.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Tue, 15 Sep 2015 22:10:55 +0900</lastBuildDate>
    <atom:link href="http://kobtea.net/tags/scala/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[Scala] sbt consoleでCtrl-Dが効かなくなったらthread設定を疑う</title>
      <link>http://kobtea.net/posts/2015/09/15/sbt-console-quit/</link>
      <pubDate>Tue, 15 Sep 2015 22:10:55 +0900</pubDate>
      
      <guid>http://kobtea.net/posts/2015/09/15/sbt-console-quit/</guid>
      <description>

&lt;h2 id=&#34;環境:21f51cd4372a33bf03ce9044b814c9d3&#34;&gt;環境&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scalaVersion := &amp;quot;2.11.6&amp;quot;

libraryDependencies += &amp;quot;com.typesafe.akka&amp;quot; %% &amp;quot;akka-actor&amp;quot; % &amp;quot;2.3.11&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;悩み:21f51cd4372a33bf03ce9044b814c9d3&#34;&gt;悩み&lt;/h2&gt;

&lt;p&gt;akkaでthread pool作って遊んでたらsbt consoleをctrl-Dで抜けられなくなった。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; import scala.concurrent.Future
scala&amp;gt; import akka.actor.ActorSystem

scala&amp;gt; implicit val ec = ActorSystem().dispatcher
ec: scala.concurrent.ExecutionContextExecutor = Dispatcher[akka.actor.default-dispatcher]

scala&amp;gt; Future(1)(ec)
res0: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@9ccb14d

scala&amp;gt; :q // consoleから抜けられない(´；ω；｀)ﾌﾞﾜｯ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;akkaが原因かな？と思い、ExecutorServiceを使ってみたけど同じくconsoleを抜けられない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; import scala.concurrent.{Future, ExecutionContext}
scala&amp;gt; import java.util.concurrent.Executors

scala&amp;gt; implicit val ec = ExecutionContext.fromExecutorService(Executors.newFixedThreadPool(1))
ec: scala.concurrent.ExecutionContextExecutorService = scala.concurrent.impl.ExecutionContextImpl$$anon$1@8a0f6d7

scala&amp;gt; Future(1)(ec)
res0: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@64918adb

scala&amp;gt; :q // consoleから抜けられない(´；ω；｀)ﾌﾞﾜｯ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;scala.concurrent.ExecutionContext.Implicits.global&lt;/code&gt;はそんなことないんだけどなぁ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; import scala.concurrent.{Future, ExecutionContext}

scala&amp;gt; implicit val ec = ExecutionContext.Implicits.global
ec: scala.concurrent.ExecutionContextExecutor = scala.concurrent.impl.ExecutionContextImpl@73be4237

scala&amp;gt; Future(1)(ec)
res0: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@42ea62b5

scala&amp;gt; :q

[success] Total time: 77 s, completed 2015/09/15 22:23:06
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;threadをdaemonにすると解決するよ:21f51cd4372a33bf03ce9044b814c9d3&#34;&gt;threadをdaemonにすると解決するよ&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Javaはデーモンスレッド以外のスレッドが終了したとき、プログラムを終了します。このとき、デーモンが処理をしているかどうかは関係ありません。なので、処理が途中でぶった切られる可能性があります。それがまずい場合はやっぱり自前でシャットダウンする機構を作るしかないのですが。。。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://nodamushi.hatenablog.com/entry/20130907/1378554253&#34;&gt;Javaでマルチスレッドするときの注意をまとめてみた&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;作成したthreadがdaemonでないから、メインのthreadを止めたあとも動き続けてしまっているらしい。&lt;br /&gt;
threadをdaemonにして再挑戦。&lt;/p&gt;

&lt;p&gt;akka版&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; import scala.concurrent.Future
scala&amp;gt; import com.typesafe.config.ConfigFactory
scala&amp;gt; import akka.actor.ActorSystem

scala&amp;gt; val config = ConfigFactory.parseString(&amp;quot;akka.daemonic = on&amp;quot;)
config: com.typesafe.config.Config = Config(SimpleConfigObject({&amp;quot;akka&amp;quot;:{&amp;quot;daemonic&amp;quot;:&amp;quot;on&amp;quot;}}))

scala&amp;gt; implicit val ec = ActorSystem(&amp;quot;default&amp;quot;, config).dispatcher
ec: scala.concurrent.ExecutionContextExecutor = Dispatcher[akka.actor.default-dispatcher]

scala&amp;gt; Future(1)(ec)
res0: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@70f8e6ab

scala&amp;gt; :q

[success] Total time: 101 s, completed 2015/09/15 23:07:48
&amp;gt; // (∩´∀｀)∩ﾜｰｲ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ExecutorService版&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; import java.util.concurrent.{Executors, ThreadFactory}
scala&amp;gt; import scala.concurrent.{ExecutionContext, Future}

scala&amp;gt; val factory = new ThreadFactory() {
     |   def newThread(r: Runnable) = {
     |     val t = new Thread(r)
     |     t.setDaemon(true)
     |     t
     |   }
     | }
factory: java.util.concurrent.ThreadFactory = $anon$1@765df09a

scala&amp;gt; implicit val ec = ExecutionContext.fromExecutorService(Executors.newFixedThreadPool(1, factory))
ec: scala.concurrent.ExecutionContextExecutorService = scala.concurrent.impl.ExecutionContextImpl$$anon$1@623404ab

scala&amp;gt; Future(1)(ec)
res0: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@5b37f8e0

scala&amp;gt; :q

[success] Total time: 42 s, completed 2015/09/15 23:41:56
&amp;gt; // (∩´∀｀)∩ﾜｰｲ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;scala.concurrent.ExecutionContext.Implicits.global&lt;/code&gt;もdaemonみたい。&lt;br /&gt;
&lt;a href=&#34;https://github.com/scala/scala/blob/v2.11.6/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L74&#34;&gt;https://github.com/scala/scala/blob/v2.11.6/src/library/scala/concurrent/impl/ExecutionContextImpl.scala#L74&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;そもそもdaemonとnon-daemonどっちがいいんです:21f51cd4372a33bf03ce9044b814c9d3&#34;&gt;そもそもdaemonとnon-daemonどっちがいいんです？&lt;/h2&gt;

&lt;p&gt;Java力低いので、&lt;code&gt;scala.concurrent.ExecutionContext.Implicits.global&lt;/code&gt;がdaemonだしdaemonでいいじゃん！程度にしか考えてない。&lt;br /&gt;
今回みたいなthread poolで使うケースだと、親のthreadが終了したら残っていても仕方ないのでdaemonで良いかな。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[Scala] Future#recoverを使って例外処理する</title>
      <link>http://kobtea.net/posts/2015/05/18/scala-future-recover/</link>
      <pubDate>Mon, 18 May 2015 20:56:24 +0900</pubDate>
      
      <guid>http://kobtea.net/posts/2015/05/18/scala-future-recover/</guid>
      <description>

&lt;h2 id=&#34;環境:cc9eddef842a840aeffa4bd7bc9900a8&#34;&gt;環境&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;➜  ~  scala
Welcome to Scala version 2.11.6 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_11).
Type in expressions to have them evaluated.
Type :help for more information.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;やりたいこと:cc9eddef842a840aeffa4bd7bc9900a8&#34;&gt;やりたいこと&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;scala.concurrent.Future&lt;/code&gt;で例外が発生して&lt;code&gt;Failure&lt;/code&gt;になったとき、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;デフォルト値を適用して&lt;code&gt;Success&lt;/code&gt;で返したい！&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Failure&lt;/code&gt;のままでいいんだけど別の例外を投げたい！&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といったことをしたい。&lt;/p&gt;

&lt;h2 id=&#34;recoverを使う:cc9eddef842a840aeffa4bd7bc9900a8&#34;&gt;recoverを使う&lt;/h2&gt;

&lt;p&gt;そんなときのための&lt;code&gt;Future#recover&lt;/code&gt;。&lt;br /&gt;
&lt;code&gt;Throwable&lt;/code&gt;をキャッチして新しい&lt;code&gt;Future&lt;/code&gt;を作ってくれる。&lt;/p&gt;

&lt;p&gt;シグネチャは以下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def recover[U &amp;gt;: T](pf: PartialFunction[Throwable, U])(implicit executor: ExecutionContext): Future[U]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ソースは&lt;a href=&#34;https://github.com/scala/scala/blob/v2.11.6/src/library/scala/concurrent/Future.scala#L310-L326&#34;&gt;この辺&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下準備&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; import scala.concurrent.Future
import scala.concurrent.Future

scala&amp;gt; import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.ExecutionContext.Implicits.global

scala&amp;gt; case class MyException() extends Exception
defined class MyException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;サンプル&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// まずはそのまま実行してみる
scala&amp;gt; Future {
     |   throw new IllegalArgumentException()
     | }
res0: scala.concurrent.Future[Nothing] = scala.concurrent.impl.Promise$DefaultPromise@b59d31

scala&amp;gt; res0.value.get
res1: scala.util.Try[Nothing] = Failure(java.lang.IllegalArgumentException)


// デフォルト値を適用したい！
scala&amp;gt; Future {
     |   throw new IllegalArgumentException()
     | } recover {
     |   case e: IllegalArgumentException =&amp;gt; 0
     | }
res2: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@2e1d27ba

scala&amp;gt; res2.value.get
res3: scala.util.Try[Int] = Success(0)


// 別の例外を投げたい！
scala&amp;gt; Future {
     |   throw new IllegalArgumentException()
     | } recover {
     |   case e: IllegalArgumentException =&amp;gt; throw MyException()
     | }
res4: scala.concurrent.Future[Nothing] = scala.concurrent.impl.Promise$DefaultPromise@3bcd05cb

scala&amp;gt; res4.value.get
res5: scala.util.Try[Nothing] = Failure(MyException)


// Successなときはそのままの結果
scala&amp;gt; Future {
     |   10
     | } recover {
     |   case e: IllegalArgumentException =&amp;gt; throw MyException()
     | }
res6: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@56928307

scala&amp;gt; res6.value.get
res7: scala.util.Try[Int] = Success(10)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;recoverwithを使う:cc9eddef842a840aeffa4bd7bc9900a8&#34;&gt;recoverWithを使う&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Future#recoverWith&lt;/code&gt;なんていうのもある。&lt;br /&gt;
&lt;code&gt;Future#recover&lt;/code&gt;とは部分関数の型が違って、&lt;code&gt;Throwable&lt;/code&gt;を受け取って&lt;code&gt;Future&lt;/code&gt;を返すようになる。&lt;/p&gt;

&lt;p&gt;シグネチャは以下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def recoverWith[U &amp;gt;: T](pf: PartialFunction[Throwable, Future[U]])(implicit executor: ExecutionContext): Future[U]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ソースは&lt;a href=&#34;https://github.com/scala/scala/blob/v2.11.6/src/library/scala/concurrent/Future.scala#L328-L348&#34;&gt;この辺&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;サンプル&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// デフォルト値を適用したい！
scala&amp;gt; Future {
     |   throw new IllegalArgumentException()
     | } recoverWith {
     |   case e: IllegalArgumentException =&amp;gt; Future.successful(0)
     | }
res8: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@463b4ac8

scala&amp;gt; res8.value.get
res9: scala.util.Try[Int] = Success(0)


// 別の例外を投げたい！
// これは特に変わらず
scala&amp;gt; Future {
     |   throw new IllegalArgumentException()
     | } recover {
     |   case e: IllegalArgumentException =&amp;gt; throw MyException()
     | }
res10: scala.concurrent.Future[Nothing] = scala.concurrent.impl.Promise$DefaultPromise@4a3e3e8b

scala&amp;gt; res10.value.get
res11: scala.util.Try[Nothing] = Failure(MyException)


// Successなときはそのままの結果
scala&amp;gt; Future {
     |   10
     | } recoverWith {
     |   case e: IllegalArgumentException =&amp;gt; Future.successful(0)
     | }
res12: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@6a1ebcff

scala&amp;gt; res12.value.get
res13: scala.util.Try[Int] = Success(10)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>